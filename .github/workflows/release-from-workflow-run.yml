name: Release from workflow run

on:
  workflow_call:
    inputs:
      tag:
        description: "Tag name for the release (without refs/tags/)."
        required: true
        type: string
      tag_prefix:
        description: "Tag prefix to validate (must start with gl-)."
        required: true
        type: string
      allow_revision_suffix:
        description: "Allow -r<digits> suffix in tag."
        required: false
        type: boolean
        default: true
      expected_version:
        description: "Optional expected version to compare against."
        required: false
        type: string
        default: ""
      run_id:
        description: "Workflow run ID to fetch artifacts from."
        required: true
        type: string
      artifact_prefix:
        description: "Prefix of the workflow artifact name to download."
        required: true
        type: string
      tarball_prefix:
        description: "Prefix for the tarball file name (without version)."
        required: true
        type: string
      checksum_prefix:
        description: "Prefix for the checksum file name (without version)."
        required: true
        type: string
      release_name:
        description: "Optional release name template (use {version} placeholder)."
        required: false
        type: string
        default: ""
      bws_version:
        description: "BWS CLI version used to fetch GitHub App secrets."
        required: false
        type: string
        default: ""
      bws_sha256:
        description: "BWS CLI sha256 checksum for the selected version."
        required: false
        type: string
        default: ""
      bws_secrets:
        description: "Comma-separated BWS secret names for GitHub App auth."
        required: false
        type: string
        default: "GH_ORG_RELEASE,GH_ORG_RELEASE_APP_ID,GH_ORG_RELEASE_APP_INSTALL_ID,GH_ORG_RELEASE_APP_PEM"
    secrets:
      token:
        description: "Optional GitHub token override."
        required: false
      BWS_ACCESS_TOKEN:
        description: "BWS access token."
        required: true
      BWS_PROJECT_ID:
        description: "BWS project id."
        required: true

jobs:
  release:
    name: Publish release
    runs-on: ubuntu-24.04
    permissions:
      contents: read
      actions: write
    steps:
      - name: Validate release tag
        id: tag
        env:
          INPUT_TAG: ${{ inputs.tag }}
          INPUT_TAG_PREFIX: ${{ inputs.tag_prefix }}
          INPUT_EXPECTED_VERSION: ${{ inputs.expected_version }}
          INPUT_ALLOW_REVISION_SUFFIX: ${{ inputs.allow_revision_suffix }}
        run: |
          set -euo pipefail
          tag="${INPUT_TAG}"
          prefix="${INPUT_TAG_PREFIX}"
          if [ -z "${tag}" ]; then
            echo "tag input is required." >&2
            exit 1
          fi
          if [ -z "${prefix}" ]; then
            echo "tag_prefix must not be empty." >&2
            exit 1
          fi
          case "${prefix}" in
            gl-*) ;;
            *)
              echo "tag_prefix must start with gl- (got: ${prefix})." >&2
              exit 1
              ;;
          esac
          if [[ "${tag}" != "${prefix}"* ]]; then
            echo "Tag ${tag} must start with ${prefix}." >&2
            exit 1
          fi
          version="${tag#${prefix}}"
          if [ -z "${version}" ]; then
            echo "Tag ${tag} does not contain a version after ${prefix}." >&2
            exit 1
          fi
          base_version="${version}"
          if [ "${INPUT_ALLOW_REVISION_SUFFIX}" = "true" ]; then
            base_version="${version%%-r*}"
          fi
          if ! [[ "${base_version}" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "Tag version ${base_version} is not a valid semver (X.Y.Z)." >&2
            exit 1
          fi
          expected="${INPUT_EXPECTED_VERSION}"
          if [ -n "${expected}" ] && [ "${base_version}" != "${expected}" ]; then
            echo "Tag version ${base_version} does not match expected ${expected}." >&2
            exit 1
          fi
          echo "tag=${tag}" >> "${GITHUB_OUTPUT}"
          echo "tag_version=${version}" >> "${GITHUB_OUTPUT}"
          echo "base_version=${base_version}" >> "${GITHUB_OUTPUT}"

      - name: Resolve GitHub App token
        id: app-token
        uses: mattycramer/gh-actions/actions/github-app-token@24fa0b1b9c20445eb84e314dde824752572595c0
        with:
          bws-access-token: ${{ secrets.BWS_ACCESS_TOKEN }}
          bws-project-id: ${{ secrets.BWS_PROJECT_ID }}
          bws-version: ${{ inputs.bws_version != '' && inputs.bws_version || vars.BWS_VERSION }}
          bws-sha256: ${{ inputs.bws_sha256 != '' && inputs.bws_sha256 || vars.BWS_SHA256 }}
          secrets: ${{ inputs.bws_secrets }}

      - name: Download artifacts
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token || secrets.token }}
          RUN_ID: ${{ inputs.run_id }}
          ARTIFACT_PREFIX: ${{ inputs.artifact_prefix }}
        run: |
          set -euo pipefail
          api="https://api.github.com/repos/${GITHUB_REPOSITORY}/actions/runs/${RUN_ID}/artifacts"
          resp="$(curl -fSs -H "Authorization: Bearer ${GH_TOKEN}" -H "Accept: application/vnd.github+json" "${api}")"
          artifact_url="$(printf '%s' "${resp}" | python3 - "${ARTIFACT_PREFIX}" <<'PY'
          import json
          import sys
          data = json.load(sys.stdin)
          prefix = sys.argv[1]
          url = ""
          for artifact in data.get("artifacts", []):
              if artifact.get("expired"):
                  continue
              name = artifact.get("name", "")
          if name.startswith(prefix):
              url = artifact.get("archive_download_url", "")
              break
          print(url)
          PY
          )"
          if [ -z "${artifact_url}" ]; then
            echo "No artifacts found for run ${RUN_ID} with prefix ${ARTIFACT_PREFIX}." >&2
            echo "${resp}" >&2
            exit 1
          fi
          mkdir -p packages
          curl -sS -L -H "Authorization: Bearer ${GH_TOKEN}" -o /tmp/artifact.zip "${artifact_url}"
          unzip -q /tmp/artifact.zip -d packages

      - name: Verify artifacts
        env:
          BASE_VERSION: ${{ steps.tag.outputs.base_version }}
          TARBALL_PREFIX: ${{ inputs.tarball_prefix }}
          CHECKSUM_PREFIX: ${{ inputs.checksum_prefix }}
        run: |
          set -euo pipefail
          tarball="${TARBALL_PREFIX}${BASE_VERSION}.tar.gz"
          checksum="${CHECKSUM_PREFIX}${BASE_VERSION}.txt"
          test -f "packages/${tarball}"
          test -f "packages/${checksum}"

      - name: Resolve release name
        id: release-name
        env:
          BASE_VERSION: ${{ steps.tag.outputs.base_version }}
          RELEASE_TEMPLATE: ${{ inputs.release_name }}
        run: |
          set -euo pipefail
          if [ -z "${RELEASE_TEMPLATE}" ]; then
            name="Release v${BASE_VERSION}"
          else
            name="${RELEASE_TEMPLATE//\{version\}/${BASE_VERSION}}"
          fi
          echo "name=${name}" >> "${GITHUB_OUTPUT}"

      - name: Create GitHub release
        uses: ncipollo/release-action@b7eabc95ff50cbeeedec83973935c8f306dfcd0b # v1.20.0
        with:
          artifacts: |
            packages/${{ inputs.tarball_prefix }}${{ steps.tag.outputs.base_version }}.tar.gz
            packages/${{ inputs.checksum_prefix }}${{ steps.tag.outputs.base_version }}.txt
          tag: ${{ steps.tag.outputs.tag }}
          name: ${{ steps.release-name.outputs.name }}
          generateReleaseNotes: true
          draft: false
          allowUpdates: true
          replacesArtifacts: true
          token: ${{ steps.app-token.outputs.token || secrets.token }}

      - name: Delete workflow artifacts and caches
        if: ${{ always() }}
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token || secrets.token }}
        run: |
          set -euo pipefail
          if [ -z "${GH_TOKEN}" ]; then
            echo "GH_TOKEN is not set; cannot delete artifacts/caches." >&2
            exit 1
          fi
          repo="${GITHUB_REPOSITORY}"
          api_base="https://api.github.com"
          page=1
          while :; do
            resp="$(curl -sS -H "Authorization: Bearer ${GH_TOKEN}" -H "Accept: application/vnd.github+json" \
              "${api_base}/repos/${repo}/actions/artifacts?per_page=100&page=${page}")"
            ids="$(printf '%s' "${resp}" | python3 - <<'PY'
            import json
            import sys
            data = json.load(sys.stdin)
            ids = [str(artifact["id"]) for artifact in data.get("artifacts", []) if artifact.get("id")]
            print("\n".join(ids))
            PY
            )"
            if [ -z "${ids}" ]; then
              break
            fi
            while IFS= read -r artifact_id; do
              [ -z "${artifact_id}" ] && continue
              status="$(curl -sS -o /tmp/delete-artifact.json -w "%{http_code}" -X DELETE \
                -H "Authorization: Bearer ${GH_TOKEN}" \
                -H "Accept: application/vnd.github+json" \
                "${api_base}/repos/${repo}/actions/artifacts/${artifact_id}")" || {
                  echo "Failed to delete artifact ${artifact_id}." >&2
                  exit 1
                }
              if [ "${status}" != "204" ] && [ "${status}" != "202" ]; then
                echo "Artifact delete failed for ${artifact_id} (status ${status})." >&2
                head -c 2000 /tmp/delete-artifact.json >&2 || true
                exit 1
              fi
            done <<< "${ids}"
            page=$((page + 1))
          done

          page=1
          while :; do
            cache_resp="$(curl -sS -H "Authorization: Bearer ${GH_TOKEN}" -H "Accept: application/vnd.github+json" \
              "${api_base}/repos/${repo}/actions/caches?per_page=100&page=${page}")"
            cache_ids="$(printf '%s' "${cache_resp}" | python3 - <<'PY'
            import json
            import sys
            data = json.load(sys.stdin)
            ids = [str(item["id"]) for item in data.get("actions_caches", []) if item.get("id")]
            print("\n".join(ids))
            PY
            )"
            if [ -z "${cache_ids}" ]; then
              break
            fi
            while IFS= read -r cache_id; do
              [ -z "${cache_id}" ] && continue
              cache_status="$(curl -sS -o /tmp/delete-cache.json -w "%{http_code}" -X DELETE \
                -H "Authorization: Bearer ${GH_TOKEN}" \
                -H "Accept: application/vnd.github+json" \
                "${api_base}/repos/${repo}/actions/caches/${cache_id}")" || {
                  echo "Failed to delete cache ${cache_id}." >&2
                  exit 1
                }
              if [ "${cache_status}" != "204" ] && [ "${cache_status}" != "202" ]; then
                echo "Cache delete failed for ${cache_id} (status ${cache_status})." >&2
                head -c 2000 /tmp/delete-cache.json >&2 || true
                exit 1
              fi
            done <<< "${cache_ids}"
            page=$((page + 1))
          done
